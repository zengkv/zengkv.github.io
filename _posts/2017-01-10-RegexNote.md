---
layout: post
title: RegexNote正则表达式笔记
categories: [blog ]
tags: [Regex, ]
description: js写的一个基于localStorage的key-value数据缓存程序
---

# RegexNote
正则表达式笔记

# 正则表达式特殊字符


<table>
  <thead>
    <tr><th colspan="2">常用元字符<th colspan="2">常用限定符<th colspan="2">常用反义词</tr>
  </thead>
  <tbody>
    <tr><td> 代码 <td>  说明<td> 代码/语法 <td> 说明<td> 代码/语法 <td> 说明
    <tr><td> . <td> 匹配除换行符以外的任意字符<td> * <td> 重复零次或更多次<td> \W <td> 匹配任意不是字母，数字，下划线，汉字的字
    <tr><td> \w <td> 匹配字母或数字或下划线<td> + <td> 重复一次或更多次<td> \S <td> 匹配任意不是空白符的字
    <tr><td> \s <td> 匹配任意的空白符<td> ? <td> 重复零次或一次<td> \D <td> 匹配任意非数字的字
    <tr><td> \d <td> 匹配数字<td> {n} <td> 重复n次<td> \B <td> 匹配不是单词开头或结束的位
    <tr><td> \b <td> 匹配单词的开始或结束<td> {n,} <td> 重复n次或更多次<td> [^x] <td> 匹配除了x以外的任意字
    <tr><td> ^ <td> 匹配字符串的开始<td> {n,m} <td> 重复n到m次<td> [^aeiou] <td> 匹配除了aeiou这几个字母以外的任意字
    <tr><td> $ <td> 匹配字符串的结束<td><td><td><td>
  </tbody>
</table>


# 正则表达式语法

>注:语法摘自轮子哥[构造正则表达式引擎](http://www.cppblog.com/vczh/archive/2008/05/22/50763.html)

## 语法目录

- [字符集合[a-z]](#字符集合)
- [并联串联[0-9][0-9]|[a-z]](#并联串联)
- [重复```[0-9]{m,n},+,*```](#重复)
- [表达式引用```(?:<sec>[a-z])(?:<sec>){2}```](#表达式引用)
- [正向预查Windows(?=98|2000)](#正向预查)
- [反向预查Windows(?!98|2000)](#反向预查)
- [匿名捕获```(?正则表达式)```](#匿名捕获)
- [命名捕获<#名字>表达式](#命名捕获)
- [命名检查<$名字>](#命名检查)
- [边界^开头$结尾](#边界)
- [非贪婪重复?](#非贪婪重复)

## 字符集合

  字符集合有很多种。举个例子，` A `就是一个字符集合，所描述的范围是只有一个字符“A”的集合。[a-z]也是一个字符集合，所描述的范围是所有小写字母。为什么这样写呢？因为小写字母的ASCII码（或者Utf16编码）是相连的，这样计算机看到的结果跟人看到的结果就一致了。[a-zA-Z0-9_]也是一个字符集合，描述了C++所有能用来表示“名称”的字符。[^a-zA-Z]也是一个字符集合，描述了除了字母以外的所有字符。除此之外，还有很多转义集合（例如\d或\x0041等），在此不赘述。

## 并联串联

  有了字符集合之后，我们就可以表达各种各样的词汇了。譬如我们使用[0-9][0-9][0-9]来表示三个数字构成的字符串，使用[0-9][0-9] | [a-z][a-z][a-z]来表达两个数字或者三个小写字母构成的字符串，还有更复杂的譬如(a | b)(c | d)来表达集合{ac,ad,bc,bd}等。

## 重复

  仅仅由并联串联是不够的，我们还可以将一个正则表达式进行“重复”以便表达更加复杂的集合。通常我们使用?来表达0-1次重复，*表达0次或以上重复，+表达1次或以上重复，{m}表达重复m次，{m,n}表达m次到n次重复，{m,}表达m次或以上重复。实际上?就是{0,1}，+就是{1,}，而*就是{0,}。每一个重复仅作用于在该重复左边最短的合法的正则表达式。譬如ab+表示{ab,abb,abbb,…}，(ab)+则表达式{ab,abab,ababab,….}。

## 表达式引用

  表达式引用可以让我们方便地表达出现很多次的复杂结构（并不是所有正则表达式引擎都支持，虽然实现起来并无难度）。举个例子，我们想使用正则表达式表达一个IPv4下的IP地址。我们知道IP地址的书写方法是XXX.XXX.XXX.XXX，但是每一个XXX的范围只能是0到255，因此我们可以把一个XXX分解成如下模式
  
  ·25[0-5]
  
  ·2[0-4][0-9]
  
  ·1[0-9][0-9]
  
  ·[1-9][0-9]
  
  ·[0-9]
  
  将它们并联起来我们得到：25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9]。显然，如果我们的正则表达式中需要书写4个这样长长的模式将会带来很多困扰。于是，这个时候表达式引用就大显身手了。我们为这个小表达式建立一个名字叫sec，然后就可以将正则表达式写成：```(?\:<sec>25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])(.(?:<sec>)){3}```了。为表达式命名的语法是(?:<名字>表达式)，而使用命名的表达式的语法是(?:<名字>)，它们的区别在于有没有在括号内书写表达式。当然，重复定义是不对的，引用无定义的表达式也是不对的，而且在一个命名表达式内部使用自己也是不对的（这是上下文无关文法的能力范围）。
  
  仅仅由以上语法构造的正则表达式称为纯正则表达式。因为这种表达式还没超出编译原理中定义的Type-3文法的表达能力。下面还要介绍一些非常实用但是超出了Type-3的语法，在本文中称为扩展正则表达式。
  
## 正向预查

正向预查的语法是(?=纯正则表达式)。代表这个地方一定要匹配所包含的表达式，但是在匹配结束之后指针并没有继续往后走。譬如我们需要在文章中搜索所有在98和2000前面的“Windows”，我们使用正则表达式Windows(?=98|2000)来完成这个任务。

## 反向预查

与正向预查相反，反向预查搜索所有不匹配的东西。譬如我们需要在文章中搜索所有不在98和2000前面的“Windows”，我们使用Windows(?!98|2000)来完成这个任务。这个很容易记住，因为C++中代表“否”用的刚好就是感叹号。嘿嘿。

## 匿名捕获

匿名捕获的语法是(?正则表达式)，如果一个正则表达式的匹配路径走过这条路的话，那么括号内所匹配的字符串将会被装进一个列表里面。举个例子，我们需要把字符串123,456,78,90中的所有数字都拿出来，我们使用```(?[0-9]+)(.(?[0-9]+))*```来完成这个任务。如果不想捕获的话，无论使用(表达式)或者是(?:表达式)都是可以的。不过(?表达式)还有其他作用。

## 命名捕获

在(?表达式)或(?:表达式)内我们都可以使用表达式引用、命名捕获和命名检查三种功能。其中命名捕获跟匿名捕获类似，它将匹配到的字符串装进一个命了名的列表里面。不过现在流行的正则表达式引擎的做法是命名捕获之能保存最后一个捕获。命名捕获的语法是<#名字>表达式。譬如我们想获得email地址的“@”两边的内容并装进两个不同的列表里面，我们使用```(?:<#user>[a-zA-Z0-9_-.]+)@(?:<#host>[a-zA-Z0-9_-.]+)```来完成这个任务。当这个正则表达式匹配了一个email地址之后，会分别把用户名和服务器装进user和host两个列表里面。

## 命名检查

命名检查在于检查接下来的字符串的前缀或全部是否跟捕获的字符串一致。命名检查的语法是<$名字>。举个例子，我们想检查一个字符串的“.”两边是否一致，譬如ab.ab、123.123、+-*/.+-*/等，我们可以使用```(?:<#part>[^.]+).(?:<$part>)```来完成这个任务。当字符串顺利到达“.”的时候，前边的部分就被放进了part表中。接下来他会检查接下来字符串是否跟表part中所保留的捕获一致。如果是ab.cd的话，part={ab}，因此匹配cd的时候就会失败。如果是cab.abc的话就会成功，而且能匹配到ab.ab。

## 边界

我们使用^代表字符串开头，使用$代表字符串结尾。因此在上面的例子中，如果我们想匹配整个字符串而不是一部分的话，我们使用```^(?:<#part>[^.]+).(?:<$part>)$```来完成这个任务。这样的话ab.ab就会成功匹配，而cab.abc就不会成功匹配了（而不是找到子串ab.ab）。如果我们想表达”^”这个字符怎么办呢？答案是使用转义\^。正则表达式的转义字符很多，不过这个跟实现是没什么关系的，到时候特殊处理一下便是。

## 非贪婪重复

在一个重复后加“?”代表让前面的重复次数尽可能少。
